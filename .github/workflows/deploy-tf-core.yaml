---
name: "Deploy Terraform Core"
run-name: "Deploy env: ${{ inputs.environment || 'poc' }}, module: ${{ inputs.module || 'all' }}, tf: ${{ inputs.action || 'plan' }}"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - poc
        default: poc
      module:
        description: "Terraform module to deploy"
        required: true
        type: choice
        default: bootstrap
        options:
          - bootstrap
          - network
          - aurora-postgres
          - shared_services
          - lambda-goose-migrator
          - all
      action:
        description: "Terraform action to perform"
        required: true
        type: choice
        options:
          - plan
          - apply
          # - destroy-plan
          # - destroy
        default: plan

env:
  AWS_REGION: "eu-west-2"
  TF_INPUT: false
  TF_IN_AUTOMATION: true

jobs:
  validate-inputs:
    name: "Validate inputs"
    runs-on: ubuntu-latest
    timeout-minutes: 1
    outputs:
      modules: ${{ steps.set-modules.outputs.modules }}
      working_dir_base: ${{ steps.set-modules.outputs.working_dir_base }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v6
        with:
          path: hometest-mgmt-terraform

      - name: "Set modules to deploy"
        id: set-modules
        run: |
          WORKING_DIR_BASE="hometest-mgmt-terraform/infrastructure/environments/${{ inputs.environment || 'poc' }}/core"
          echo "working_dir_base=${WORKING_DIR_BASE}" >> "$GITHUB_OUTPUT"

          if [ "${{ inputs.module || 'all' }}" == "all" ]; then
            # Deploy in dependency order
            echo 'modules=["bootstrap", "network", "aurora-postgres", "shared_services", "lambda-goose-migrator"]' >> "$GITHUB_OUTPUT"
          else
            echo 'modules=["${{ inputs.module || 'all' }}"]' >> "$GITHUB_OUTPUT"
          fi

      - name: "Validate module path exists"
        run: |
          BASE_PATH="hometest-mgmt-terraform/infrastructure/environments/${{ inputs.environment || 'poc' }}/core"
          if [ "${{ inputs.module || 'all' }}" != "all" ]; then
            if [ ! -d "${BASE_PATH}/${{ inputs.module || 'all' }}" ]; then
              echo "::error::Module path '${BASE_PATH}/${{ inputs.module || 'all' }}' does not exist"
              exit 1
            fi
          fi

      - name: "Display deployment info"
        run: |
          {
            echo "## Deployment Configuration"
            echo "| Parameter | Value |"
            echo "|-----------|---------|"
            echo "| Environment | ${{ inputs.environment || 'poc' }} |"
            echo "| Stack | core |"
            echo "| Module(s) | ${{ inputs.module || 'all' }} |"
            echo "| Action | ${{ inputs.action || 'plan' }} |"
            echo "| Triggered by | ${{ github.actor }} |"
          } >> "$GITHUB_STEP_SUMMARY"

  deploy:
    name: "Deploy ${{ matrix.module }}"
    runs-on: ubuntu-latest
    needs: [validate-inputs]
    timeout-minutes: 30
    permissions:
      id-token: write
      contents: read
    strategy:
      fail-fast: true
      max-parallel: 1  # Sequential deployment to respect dependencies
      matrix:
        module: ${{ fromJson(needs.validate-inputs.outputs.modules) }}
    steps:
      - name: "Checkout code"
        uses: actions/checkout@v6
        with:
          path: hometest-mgmt-terraform

      - name: "Deploy ${{ matrix.module }}"
        uses: ./hometest-mgmt-terraform/.github/actions/deploy-terragrunt
        with:
          aws_role_arn: ${{ secrets.AWS_ROLE_ARN }}
          aws_region: ${{ env.AWS_REGION }}
          working_directory: ${{ needs.validate-inputs.outputs.working_dir_base }}/${{ matrix.module }}
          action: ${{ inputs.action || 'plan' }}

      - name: "Invoke Lambda migrator and print logs"
        if: matrix.module == 'lambda-goose-migrator' && (inputs.action == 'apply')
        run: |
          # Find the Lambda function by name pattern
          FUNCTION_NAME=$(aws lambda list-functions \
            --query "Functions[?contains(FunctionName, 'lambda-goose-migrator')].FunctionName | [0]" \
            --output text)

          if [ -z "$FUNCTION_NAME" ] || [ "$FUNCTION_NAME" == "None" ]; then
            echo "::error::Could not find Lambda function matching 'lambda-goose-migrator'"
            exit 1
          fi

          echo "Found Lambda function: ${FUNCTION_NAME}"
          LOG_GROUP="/aws/lambda/${FUNCTION_NAME}"

          # Record start time before invocation for CloudWatch log filtering
          START_TIME_MS=$(date +%s%3N)

          # Invoke the Lambda synchronously; --log-type Tail returns last 4 KB of logs.
          # --cli-read-timeout 0 disables the default 60s socket read timeout so the CLI
          # waits for the full Lambda execution (max 15 min) before returning.
          echo "Invoking Lambda function..."
          aws lambda invoke \
            --function-name "$FUNCTION_NAME" \
            --invocation-type RequestResponse \
            --log-type Tail \
            --cli-read-timeout 0 \
            --payload '{}' \
            /tmp/lambda-response.json > /tmp/lambda-invoke-meta.json

          STATUS_CODE=$(jq -r '.StatusCode // empty' /tmp/lambda-invoke-meta.json)
          FUNCTION_ERROR=$(jq -r '.FunctionError // empty' /tmp/lambda-invoke-meta.json)
          LOG_RESULT_B64=$(jq -r '.LogResult // empty' /tmp/lambda-invoke-meta.json)

          echo "Status code: ${STATUS_CODE}"

          # Decode inline log tail and extract the RequestId
          LOG_TAIL=""
          REQUEST_ID=""
          if [ -n "$LOG_RESULT_B64" ]; then
            LOG_TAIL=$(echo "$LOG_RESULT_B64" | base64 -d)
            REQUEST_ID=$(echo "$LOG_TAIL" | grep -oP 'START RequestId: \K[a-f0-9-]+' || true)
          fi
          echo "Request ID: ${REQUEST_ID}"

          # Find the exact log stream for this invocation via RequestId
          LOGS=""
          if [ -n "$REQUEST_ID" ]; then
            echo "Waiting for CloudWatch to ingest logs..."
            sleep 10

            echo "Fetching CloudWatch logs for RequestId ${REQUEST_ID}..."
            MAX_WAIT=60
            ELAPSED=0
            INTERVAL=5
            while [ "$ELAPSED" -lt "$MAX_WAIT" ]; do
              LOGS=$(aws logs filter-log-events \
                --log-group-name "$LOG_GROUP" \
                --filter-pattern "\"$REQUEST_ID\"" \
                --start-time "$START_TIME_MS" \
                --query "events[*].message" \
                --output text 2>/dev/null || true)
              if [ -n "$LOGS" ]; then
                break
              fi
              echo "  Still waiting for logs... (${ELAPSED}s elapsed)"
              sleep "$INTERVAL"
              ELAPSED=$(( ELAPSED + INTERVAL ))
            done
          fi

          # Print logs to the job output and the step summary
          echo "=== Lambda Execution Logs ==="
          if [ -n "$LOGS" ]; then
            echo "$LOGS"

            {
              echo "### Lambda Migrator Logs"
              echo "**Function**: \`${FUNCTION_NAME}\`"
              echo "**Request ID**: \`${REQUEST_ID}\`"
              echo '```'
              echo "$LOGS"
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
          else
            # Fall back to the inline tail returned by the invoke call
            echo "::warning::Could not fetch CloudWatch logs; printing inline log tail."
            echo "$LOG_TAIL"
            {
              echo "### Lambda Migrator Logs (tail)"
              echo "**Function**: \`${FUNCTION_NAME}\`"
              echo "**Request ID**: \`${REQUEST_ID}\`"
              echo '```'
              echo "$LOG_TAIL"
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
          fi

          # Fail the step if the Lambda itself reported an error
          if [ -n "$FUNCTION_ERROR" ] && [ "$FUNCTION_ERROR" != "null" ]; then
            echo "::error::Lambda function error: ${FUNCTION_ERROR}"
            echo "Function response:"
            cat /tmp/lambda-response.json
            exit 1
          fi

      - name: "Post deployment summary"
        if: always()
        run: |
          {
            echo "## Module: ${{ matrix.module }}"
            echo "- **Status**: ${{ job.status }}"
            echo "- **Action**: ${{ inputs.action || 'plan' }}"
            echo "- **Path**: ${{ needs.validate-inputs.outputs.working_dir_base }}/${{ matrix.module }}"
          } >> "$GITHUB_STEP_SUMMARY"

  summary:
    name: "Deployment Summary"
    runs-on: ubuntu-latest
    needs: [validate-inputs, deploy]
    if: always()
    steps:
      - name: "Generate summary"
        run: |
          {
            echo "## Deployment Complete"
            echo ""
            echo "| Detail | Value |"
            echo "|--------|-------|"
            echo "| Environment | ${{ inputs.environment || 'poc' }} |"
            echo "| Stack | core |"
            echo "| Module(s) | ${{ inputs.module || 'all' }} |"
            echo "| Action | ${{ inputs.action || 'plan' }} |"
            echo "| Overall Status | ${{ needs.deploy.result }} |"
            echo "| Run ID | ${{ github.run_id }} |"
            echo "| Triggered by | ${{ github.actor }} |"
          } >> "$GITHUB_STEP_SUMMARY"
